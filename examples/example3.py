from ProvIt import ProvenanceEngine


# define your methods
def add(x, y):
    # add two numbers
    z = x + y
    return z

def subtract(x,y):
    # subtract two numbers
    z = x - y
    return z



def arbitraryOuterMethod(x, y ,xID, yID, engine):
    # to track the provenance of a nested method inside an outer method,
    # the outer method needs to be provided with the provenanceEngine-object
    # and the IDs of the input. 
    # this should be by giving it as parameter, since it makes the methods 
    # more generic.
    # python scoping rules could also be leveraged

    # add process to graph

    # if scope is true, additional information from which scope in your program
    # the added method was called is added.
    # in this case: addID wasCalledFromScope arbitraryOuterMethod
    # if the nesting is deeper the hierarchy of the scopes is indicated by '/'
    # e.g.: addID wasCalledFromScope arbitraryOuterMethod/arbitraryInnerMethod
    addID = engine.addProcess(
        label = 'add',
        description = 'adds two numbers and gives out a sum',
        scope = True
    )

    z = add(x,y)

    zID = engine.addEntity(
        label = 'Variable z',
        description = "its value is: " + str(z)
    )

    engine.relateProcessAndEntities(
        inputIDs = [xID,yID],
        outputIDs = zID,
        processID = addID
    )

    three = 3
    threeID = engine.addEntity(
        label = 'constant three',
        description = "its value is: " + str(three)
    )

    # add process to graph
    subID = engine.addProcess(
            label = 'subtract',
            description = 'subtracts two numbers',
            scope = True
        )

    result = subtract(z, three)

    resultID = engine.addEntity(
        label = 'result',
        description = "its value is: " + str(result)
    )
    
    engine.relateProcessAndEntities(
        inputIDs = [zID, threeID],
        outputIDs = resultID,
        processID = subID
    )
    
    return result, resultID


# setup the provenance engine object and provide it with a namespace
provEngine = ProvenanceEngine(
    namespace = 'https://usefulmodulecollection.org/modul1#', 
    abbreviation = 'm1'
)

a = 6
aID = provEngine.addEntity(
        label = 'Variable a',
        description = "its value is: " + str(a)
    )

b = 3
bID = provEngine.addEntity(
        label = 'Variable b',
        description = "its value is: " + str(b)
    )

# we need to define the output entities inside the outer method, since 
# they get generated by processes defined inside the method.
# this is no violation of the recommendation given in the documentation, because
# when nested methods are tracked, the outer method can't (really should not) be 
# tracked.
# an additional parameter in addProcess() will help to preserve the knowledge about 
# the scopes. 

c, cID = arbitraryOuterMethod(a, b, aID, bID, provEngine)


# save the graph in the Turtle format
provEngine.serialize('example3.ttl')

print(c)